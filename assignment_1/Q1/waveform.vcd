$date
	Sat Aug 20 12:00:51 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module adder_test $end
$var wire 1 ! overflow $end
$var wire 8 " final_sum [7:0] $end
$var wire 1 # final_carry_out $end
$var reg 8 $ data0 [7:0] $end
$var reg 8 % data1 [7:0] $end
$var reg 1 & mode $end
$scope module uut $end
$var wire 8 ' data0 [7:0] $end
$var wire 8 ( data1 [7:0] $end
$var wire 1 & mode $end
$var wire 1 ! overflow $end
$var wire 8 ) final_sum [7:0] $end
$var wire 1 # final_carry_out $end
$var wire 7 * c [6:0] $end
$var reg 1 + carry_in $end
$scope begin genblk1[1] $end
$scope module add $end
$var wire 1 , carry_in $end
$var wire 1 - i0 $end
$var wire 1 . i1 $end
$var wire 1 & mode $end
$var reg 1 / carry_out $end
$var reg 1 0 sum $end
$upscope $end
$upscope $end
$scope begin genblk1[2] $end
$scope module add $end
$var wire 1 1 carry_in $end
$var wire 1 2 i0 $end
$var wire 1 3 i1 $end
$var wire 1 & mode $end
$var reg 1 4 carry_out $end
$var reg 1 5 sum $end
$upscope $end
$upscope $end
$scope begin genblk1[3] $end
$scope module add $end
$var wire 1 6 carry_in $end
$var wire 1 7 i0 $end
$var wire 1 8 i1 $end
$var wire 1 & mode $end
$var reg 1 9 carry_out $end
$var reg 1 : sum $end
$upscope $end
$upscope $end
$scope begin genblk1[4] $end
$scope module add $end
$var wire 1 ; carry_in $end
$var wire 1 < i0 $end
$var wire 1 = i1 $end
$var wire 1 & mode $end
$var reg 1 > carry_out $end
$var reg 1 ? sum $end
$upscope $end
$upscope $end
$scope begin genblk1[5] $end
$scope module add $end
$var wire 1 @ carry_in $end
$var wire 1 A i0 $end
$var wire 1 B i1 $end
$var wire 1 & mode $end
$var reg 1 C carry_out $end
$var reg 1 D sum $end
$upscope $end
$upscope $end
$scope begin genblk1[6] $end
$scope module add $end
$var wire 1 E carry_in $end
$var wire 1 F i0 $end
$var wire 1 G i1 $end
$var wire 1 & mode $end
$var reg 1 H carry_out $end
$var reg 1 I sum $end
$upscope $end
$upscope $end
$scope module add1 $end
$var wire 1 + carry_in $end
$var wire 1 J i0 $end
$var wire 1 K i1 $end
$var wire 1 & mode $end
$var reg 1 L carry_out $end
$var reg 1 M sum $end
$upscope $end
$scope module add8 $end
$var wire 1 N carry_in $end
$var wire 1 O i0 $end
$var wire 1 P i1 $end
$var wire 1 & mode $end
$var reg 1 # carry_out $end
$var reg 1 Q sum $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0Q
0P
0O
0N
0M
0L
0K
0J
0I
0H
0G
0F
0E
0D
0C
0B
0A
0@
0?
0>
0=
0<
0;
0:
09
08
07
06
05
04
03
02
01
00
0/
0.
0-
0,
0+
b0 *
b0 )
b0 (
b0 '
1&
b0 %
b0 $
0#
b0 "
0!
$end
#5
b1 "
b1 )
1M
1J
b1 $
b1 '
#10
b11 "
b11 )
10
1-
0J
1K
b10 $
b10 '
b1 %
b1 (
#15
15
11
1/
00
1,
b11 *
1L
b100 "
b100 )
0M
1J
b11 $
b11 '
#20
01
0:
0/
10
06
0,
04
b110 "
b110 )
15
b0 *
0L
0-
12
0J
1.
0K
b100 $
b100 '
b10 %
b10 (
#25
b111 "
b111 )
1M
1J
b101 $
b101 '
#30
1:
16
14
05
11
b110 *
1/
b1001 "
b1001 )
00
1-
0J
1K
b110 $
b110 '
b11 %
b11 (
#35
1#
0!
1N
1H
1E
1C
1@
1>
1,
11
1;
1L
0M
0Q
1/
00
15
b1111111 *
19
0:
0?
0D
b100 "
b100 )
0I
1J
1+
b111 $
b111 '
0&
#40
06
b100 "
b100 )
0:
b1111011 *
04
0-
02
17
0J
0.
13
0K
b1000 $
b1000 '
b100 %
b100 (
#45
b101 "
b101 )
1M
1J
b1001 $
b1001 '
#50
0,
b101 "
b101 )
00
b1111010 *
0L
1-
0J
1K
b1010 $
b1010 '
b101 %
b101 (
#55
10
1,
b1111011 *
1L
b110 "
b110 )
0M
1J
b1011 $
b1011 '
#60
0:
06
01
04
b110 "
b110 )
15
b1111001 *
0/
0-
12
0J
1.
0K
b1100 $
b1100 '
b110 %
b110 (
#65
b111 "
b111 )
1M
1J
b1101 $
b1101 '
#70
0,
11
16
1;
0@
0E
0N
0L
0#
0Q
1/
00
14
15
19
0:
0>
1?
0C
0D
b1110 *
0H
b10101 "
b10101 )
0I
1-
0J
1K
0+
b1110 $
b1110 '
b111 %
b111 (
1&
#75
10
1,
b1111 *
1L
b10110 "
b10110 )
0M
1J
b1111 $
b1111 '
